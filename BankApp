import customtkinter
import customtkinter as ctk
import pyodbc
import sys
from tkinter import messagebox
import requests
import random
from tkinter import simpledialog
import datetime
from decimal import Decimal
import pandas as pd
import joblib
from scipy.stats import boxcox
import numpy as np
from urllib.parse import quote_plus
import threading
from sqlalchemy import create_engine, text


# Параметры подключения к базе данных SQL Server
server = 'DESKTOP-3T1O5TL'
database = 'BankAppDB'

connection_str = (
    f"DRIVER={{ODBC Driver 18 for SQL Server}};"
    f"SERVER={server};"
    f"DATABASE={database};"
    "ENCRYPT=yes;"
    "TrustServerCertificate=yes;"
    "Trusted_Connection=yes;"
)

class AppBank(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Bank Application")
        self.geometry("800x600")

        # Подключение к базе данных
        try:
            self.conn = pyodbc.connect(connection_str)
        except pyodbc.Error as e:
            messagebox.showerror("Connection error", f"Failed to connect to the database: {e}")
            sys.exit(1)

        # Инициализация фреймов
        self.main_frame = ctk.CTkFrame(self, width=800, height=600)
        self.main_frame.pack(fill="both", expand=True)

        customtkinter.set_default_color_theme("green")

        # Показать фрейм авторизации
        self.show_login_frame()

    def show_login_frame(self):
        """Отображает фрейм авторизации."""
        self.clear_frame()

        # Заголовок
        label = ctk.CTkLabel(self.main_frame, text="Login to Bank Application", font=("Arial", 25, "bold"))
        label.place(relx=0.5, rely=0.1, anchor="center")  # Центрируем

        # Поля для ввода данных
        self.phone_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Phone")
        self.phone_entry.place(relx=0.5, rely=0.3, anchor="center")  # Центрируем

        self.password_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Password", show="*")
        self.password_entry.place(relx=0.5, rely=0.4, anchor="center")

        # Кнопка входа
        login_button = ctk.CTkButton(self.main_frame, text="Login", command=self.login_user)
        login_button.place(relx=0.5, rely=0.5, anchor="center")

        # Кнопка регистрации
        register_button = ctk.CTkButton(self.main_frame, text="Register", command=self.show_register_frame)
        register_button.place(relx=0.5, rely=0.6, anchor="center")

        # Настройки внешнего вида
        appearance_label = ctk.CTkLabel(self.main_frame, text="Appearance Mode:", font=("Arial", 12))
        appearance_label.place(relx=0.4, rely=0.7, anchor="center")

        appearance_menu = ctk.CTkOptionMenu(self.main_frame,
                                            values=["Light", "Dark"],
                                            command=self.change_appearance_mode_event)
        appearance_menu.place(relx=0.6, rely=0.7, anchor="center")

    def show_register_frame(self):
        """Отображает фрейм регистрации."""
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Register New Account", font=("Arial", 20))
        label.pack(pady=20)

        # Поля для ввода данных
        self.first_name_entry = ctk.CTkEntry(self.main_frame, placeholder_text="First Name")
        self.first_name_entry.pack(pady=10)
        self.last_name_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Last Name")
        self.last_name_entry.pack(pady=10)
        self.phone_register_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Phone")
        self.phone_register_entry.pack(pady=10)
        self.dob_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Date of Birth (YYYY-MM-DD)")
        self.dob_entry.pack(pady=10)
        self.gender_var = ctk.StringVar(value="Select Gender")  # Переменная для хранения выбранного значения
        self.gender_menu = ctk.CTkOptionMenu(self.main_frame, variable=self.gender_var,
                                             values=["Male", "Female", "Other"])
        self.gender_menu.pack(pady=10)
        self.password_register_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Password", show="*")
        self.password_register_entry.pack(pady=10)

        # Кнопка для регистрации
        register_button = ctk.CTkButton(self.main_frame, text="Register", command=self.register_user)
        register_button.pack(pady=10)

        # Кнопка возврата к авторизации
        back_button = ctk.CTkButton(self.main_frame, text="Back to Login", command=self.show_login_frame)
        back_button.pack(pady=10)

    def login_user(self):
        """Проверяет данные пользователя (клиент или сотрудник) и входит в систему."""
        phone = self.phone_entry.get()
        password = self.password_entry.get()

        if not phone or not password:
            messagebox.showerror("Error", "Enter your phone and password")
            return

        cursor = self.conn.cursor()

        # Проверяем, является ли пользователь сотрудником
        employee_query = "SELECT employee_id, firstname, lastname FROM employees WHERE phone = ? AND password = ?"
        cursor.execute(employee_query, (phone, password))
        employee = cursor.fetchone()

        if employee:
            employee_id, firstname, lastname = employee
            messagebox.showinfo("Successfully", f"Welcome, {firstname} {lastname}! (Employee)")

            # Сохраняем ID сотрудника
            self.current_employee_id = employee_id

            # Переход на фрейм сотрудника
            self.show_employee_frame(employee_id)
            return

        # Проверяем, является ли пользователь клиентом
        customer_query = "SELECT customer_id, first_name, last_name FROM customer WHERE phone = ? AND password = ?"
        cursor.execute(customer_query, (phone, password))
        customer = cursor.fetchone()

        if customer:
            customer_id, first_name, last_name = customer
            messagebox.showinfo("Successfully", f"Welcome, {first_name} {last_name}!")

            # Сохраняем ID клиента
            self.current_customer_id = customer_id

            # Проверяем, есть ли у клиента активный счет
            account_query = "SELECT account_number FROM accounts WHERE customer_id = ?"
            cursor.execute(account_query, (self.current_customer_id,))
            account = cursor.fetchone()

            if account:
                self.current_account_number = account[0]
            else:
                self.current_account_number = None
                messagebox.showwarning("Attention", "The user does not have an active account.")

            # Переход на интерфейс клиента
            self.show_bank_frame(customer_id)
            return

        # Если пользователь не найден ни среди клиентов, ни среди сотрудников
        messagebox.showerror("Error", "Invalid phone number or password")

    def register_user(self):
        """Регистрирует нового пользователя и создаёт для него активный банковский счёт с уникальным номером."""
        first_name = self.first_name_entry.get()
        last_name = self.last_name_entry.get()
        phone = self.phone_register_entry.get()
        dob = self.dob_entry.get()
        gender = self.gender_var.get()
        password = self.password_register_entry.get()

        if not all([first_name, last_name, phone, dob, password]) or gender == "Select Gender":
            messagebox.showerror("Error", "Fill in all the fields and select the gender!")
            return

        # Проверка номера телефона
        if not (phone.startswith("+7") and len(phone) == 12 and phone[1:].isdigit()):
            messagebox.showerror("Error", "Enter the correct phone number in the format +7XXXXXXXXXX!")
            return

        # Генерация уникального номера счета
        account_number = self.generate_account_number()

        cursor = self.conn.cursor()
        try:
            # Вставляем данные нового пользователя
            query_customer = """
            INSERT INTO customer (first_name, last_name, phone, date_of_birth, gender, [password])
            OUTPUT INSERTED.customer_id
            VALUES (?, ?, ?, ?, ?, ?)
            """
            cursor.execute(query_customer, (first_name, last_name, phone, dob, gender, password))

            # Получаем ID созданного пользователя сразу через OUTPUT
            customer_id = cursor.fetchone()[0]

            # Создаём для него активный банковский счёт
            query_account = """
            INSERT INTO accounts (account_number, customer_id)
            VALUES (?, ?)
            """
            cursor.execute(query_account, (account_number, customer_id))
            self.conn.commit()

            messagebox.showinfo(
                "Successfully",
                f"You have successfully registered! Your account number: {account_number}"
            )
            self.show_login_frame()
        except pyodbc.Error as e:
            self.conn.rollback()  # Откат изменений в случае ошибки
            messagebox.showerror("Error", f"Failed to register: {e}")

    def generate_account_number(self):
        """Генерирует уникальный номер счета, соответствующий требованиям базы данных."""
        while True:
            # Генерация номера счета, начинающегося с 4400
            account_number = f"4400{''.join(str(random.randint(0, 9)) for _ in range(8))}"

            # Проверка на уникальность в базе данных
            cursor = self.conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM accounts WHERE account_number = ?", (account_number,))
            if cursor.fetchone()[0] == 0:
                return account_number

    def show_bank_frame(self, customer_id):
        """Отображает фрейм 'Мой банк'."""
        self.clear_frame()

        # Заголовок
        title_label = ctk.CTkLabel(
            self.main_frame,
            text="My Bank",
            font=("Arial", 24, "bold")
        )
        title_label.pack(pady=(20, 10))

        # Получение баланса пользователя
        cursor = self.conn.cursor()
        query_balance = "SELECT balance, currency FROM accounts WHERE customer_id = ? AND is_active = 1"
        cursor.execute(query_balance, (customer_id,))
        account = cursor.fetchone()

        if account:
            balance, currency = account
            # Баланс
            balance_frame = ctk.CTkFrame(self.main_frame, border_width=2, corner_radius=8)
            balance_frame.pack(pady=10, padx=20, fill="x")

            balance_label = ctk.CTkLabel(
                balance_frame,
                text=f"Balance: {balance:.2f} {currency}",
                font=("Arial", 16)
            )
            balance_label.pack(pady=10)
        else:
            balance_label = ctk.CTkLabel(
                self.main_frame,
                text="No active account found",
                font=("Arial", 14, "italic")
            )
            balance_label.pack(pady=10)
            return

        # Курсы валют
        try:
            # API для получения валютных курсов
            response = requests.get("https://api.exchangerate-api.com/v4/latest/USD")
            data = response.json()
            rates = data["rates"]

            # Оставляем только нужные валюты
            allowed_currencies = ["USD", "RUB", "KZT", "CHF", "GBP", "CNY", "EUR"]
            filtered_rates = {code: rate for code, rate in rates.items() if code in allowed_currencies}

            # Рамка для курсов валют
            rates_frame = ctk.CTkFrame(self.main_frame, border_width=2, corner_radius=8)
            rates_frame.pack(pady=10, padx=20, anchor="center")

            rates_label = ctk.CTkLabel(
                rates_frame,
                text="Exchange Rates",
                font=("Arial", 16, "bold")
            )
            rates_label.pack(pady=(10, 5))

            # Строка с курсами валют
            rates_row_frame = ctk.CTkFrame(rates_frame)
            rates_row_frame.pack(pady=(5, 10), padx=10, fill="x")

            for code, rate in filtered_rates.items():
                rate_label = ctk.CTkLabel(
                    rates_row_frame,
                    text=f"{code}: {rate:.2f}",
                    font=("Arial", 12)
                )
                rate_label.pack(side="left", padx=10)  # Размещаем все курсы в строку
        except Exception as e:
            error_label = ctk.CTkLabel(
                self.main_frame,
                text=f"Failed to fetch currency rates: {e}",
                font=("Arial", 12, "italic"),
                text_color="red"
            )
            error_label.pack(pady=10)

        # Операционные кнопки
        buttons_frame = ctk.CTkFrame(self.main_frame, corner_radius=8)
        buttons_frame.pack(pady=20, padx=20, fill="x")

        buttons = [
            ("Transaction", self.show_transaction_frame),
            ("Deposit", self.show_deposit_frame),
            ("Credit", self.show_credit_frame),
            ("Stocks", self.show_stocks_frame)
        ]

        for text, command in buttons:
            button = ctk.CTkButton(
                buttons_frame,
                text=text,
                command=command
            )
            button.pack(pady=5)

        # Кнопка выхода
        logout_button = ctk.CTkButton(
            self.main_frame,
            text="Logout",
            command=self.show_login_frame
        )
        logout_button.pack(pady=20)

    def show_transaction_frame(self):
        """Отображает фрейм для совершения транзакций."""
        self.clear_frame()

        # Заголовок
        label = ctk.CTkLabel(self.main_frame, text="New Transaction", font=("Arial", 20))
        label.pack(pady=20)

        # Поле для ввода номера целевого счета
        target_account_label = ctk.CTkLabel(self.main_frame, text="Target Account (12 digits):")
        target_account_label.pack(pady=5)
        self.target_account_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Enter account number")
        self.target_account_entry.pack(pady=5)

        # Поле для ввода суммы перевода
        amount_label = ctk.CTkLabel(self.main_frame, text="Amount:")
        amount_label.pack(pady=5)
        self.amount_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Enter amount")
        self.amount_entry.pack(pady=5)

        # Поле для ввода описания
        description_label = ctk.CTkLabel(self.main_frame, text="Description (optional):")
        description_label.pack(pady=5)
        self.description_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Enter description")
        self.description_entry.pack(pady=5)

        # Кнопка для подтверждения транзакции
        transfer_button = ctk.CTkButton(
            self.main_frame, text="Make Transfer", command=self.perform_transaction
        )
        transfer_button.pack(pady=20)

        # Кнопка возврата
        back_button = ctk.CTkButton(
            self.main_frame,
            text="Back to menu",
            command=lambda: self.show_bank_frame(self.current_customer_id)
        )
        back_button.pack(pady=10)

    def perform_transaction(self):
        """Обрабатывает перевод между счетами с проверкой на мошенничество."""
        target_account = self.target_account_entry.get()
        amount = self.amount_entry.get()
        description = self.description_entry.get()

        # Проверка данных
        if not target_account or not amount:
            messagebox.showerror("Error", "Enter the account number and amount")
            return

        try:
            amount = Decimal(amount)  # Используем Decimal вместо float
            if amount <= 0:
                raise ValueError("The amount must be positive")
        except Exception as e:
            messagebox.showerror("Error", f"Incorrect amount: {e}")
            return

        # Проверка формата целевого счета
        if not (target_account.startswith("4400") and len(target_account) == 12):
            messagebox.showerror("Error", "Invalid target account format")
            return

        try:
            cursor = self.conn.cursor()

            # Проверка текущего баланса отправителя
            cursor.execute(
                "SELECT balance FROM accounts WHERE account_number = ?",
                (self.current_account_number,)
            )
            sender_balance = cursor.fetchone()
            if sender_balance is None:
                messagebox.showerror("Error", "The sender's account was not found")
                return

            sender_balance = sender_balance[0]
            if sender_balance < amount:
                messagebox.showerror("Error", "Insufficient funds in the account")
                return

            # Проверка существования целевого счета
            cursor.execute(
                "SELECT balance FROM accounts WHERE account_number = ?",
                (target_account,)
            )
            target_account_balance = cursor.fetchone()
            if target_account_balance is None:
                messagebox.showerror("Error", "The target account was not found")
                return

            target_account_balance = target_account_balance[0]

            # Определение новых балансов
            new_sender_balance = sender_balance - amount
            new_target_balance = target_account_balance + amount

            # Расчет времени и шага (step)
            transaction_date = datetime.datetime.now()
            start_date = datetime.datetime(transaction_date.year, transaction_date.month, 1)
            step = (transaction_date - start_date).days * 24 + (transaction_date - start_date).seconds // 3600

            # Добавление записи о транзакции со статусом 'pending'
            cursor.execute(
                """
                INSERT INTO transactions (
                    account_from, account_to, amount, transaction_type, description, status, 
                    oldBalanceOrig, newBalanceOrig, oldBalanceDest, newBalanceDest, isFlaggedFraud, transaction_date
                )
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    self.current_account_number,  # Номер счета отправителя
                    target_account,  # Номер счета получателя
                    amount,  # Сумма
                    "Transfer",  # Тип транзакции
                    description,  # Описание
                    "pending",  # Статус транзакции
                    sender_balance,  # Старый баланс отправителя
                    new_sender_balance,  # Новый баланс отправителя
                    target_account_balance,  # Старый баланс получателя
                    new_target_balance,  # Новый баланс получателя
                    0,  # Флаг подозрительности (изначально 0)
                    transaction_date  # Дата транзакции
                )
            )

            # Сохранение изменений
            self.conn.commit()
            messagebox.showinfo("Successfully", f"The transaction was created with the status 'pending'. Step: {step}")

        except Exception as e:
            self.conn.rollback()  # Откат изменений в случае ошибки
            messagebox.showerror("Error", f"Transaction execution error: {e}")

    def show_stocks_frame(self):
        """Показать фрейм для акций."""
        self.clear_frame()

        # Заголовок
        title_label = ctk.CTkLabel(
            self.main_frame,
            text="Top 10 Exchanges",
            font=("Arial", 24, "bold")
        )
        title_label.pack(pady=(20, 10))

        try:
            # API-запрос к биржам (пример для CoinGecko API)
            response = requests.get("https://api.coingecko.com/api/v3/exchanges")
            data = response.json()

            # Получение топ-10 бирж
            top_exchanges = data[:10]

            # Рамка для списка бирж
            exchanges_frame = ctk.CTkFrame(self.main_frame, border_width=2, corner_radius=8)
            exchanges_frame.pack(pady=10, padx=10, fill="both", expand=True)

            # Отображение списка бирж
            for exchange in top_exchanges:
                name = exchange.get("name", "Unknown")
                country = exchange.get("country", "Unknown")
                trade_volume = exchange.get("trade_volume_24h_btc", 0)

                # Внутренняя рамка для биржи
                exchange_row = ctk.CTkFrame(exchanges_frame, corner_radius=5)
                exchange_row.pack(pady=5, padx=5, fill="x", expand=True)

                # Название биржи
                name_label = ctk.CTkLabel(
                    exchange_row,
                    text=name,
                    font=("Arial", 14, "bold")
                )
                name_label.pack(side="left", padx=10)

                # Страна
                country_label = ctk.CTkLabel(
                    exchange_row,
                    text=f"Country: {country}",
                    font=("Arial", 12)
                )
                country_label.pack(side="left", padx=10)

                # Объем торгов
                volume_label = ctk.CTkLabel(
                    exchange_row,
                    text=f"24h Volume: {trade_volume:.2f} BTC",
                    font=("Arial", 12)
                )
                volume_label.pack(side="right", padx=10)

        except Exception as e:
            error_label = ctk.CTkLabel(
                self.main_frame,
                text=f"Failed to fetch stock data: {e}",
                font=("Arial", 12, "italic")
            )
            error_label.pack(pady=10)

        # Кнопка возврата в главное меню
        back_button = ctk.CTkButton(
            self.main_frame,
            text="Back",
            command=lambda: self.show_bank_frame(self.current_customer_id)
        )
        back_button.pack(pady=20)


    def show_deposit_frame(self):
        """Отображает фрейм для управления депозитом."""
        self.clear_frame()

        # Заголовок
        label = ctk.CTkLabel(self.main_frame, text="Manage Deposit", font=("Arial", 20))
        label.pack(pady=20)

        # Подключение к базе данных, чтобы получить информацию о депозите
        try:
            cursor = self.conn.cursor()
            query = """
                SELECT deposit_id, amount, interest_rate, start_date, end_date
                FROM deposit
                WHERE account = ?
            """
            cursor.execute(query, (self.current_account_number,))
            deposit = cursor.fetchone()

            if deposit:  # Если депозит уже существует
                deposit_id, amount, interest_rate, start_date, end_date = deposit

                # Отображение информации о депозите
                deposit_info = ctk.CTkLabel(
                    self.main_frame,
                    text=(f"Deposit Balance: {amount:.2f} USD\n"
                          f"Interest Rate: {interest_rate:.2f}%\n"
                          f"Start Date: {start_date}\n"
                          f"End Date: {end_date if end_date else 'Active'}"),
                    font=("Arial", 14),
                    anchor="w"
                )
                deposit_info.pack(pady=10)

                # Кнопка для перевода средств с депозита на свой счет
                withdraw_button = ctk.CTkButton(
                    self.main_frame,
                    text="Withdraw to Account",
                    command=lambda: self.withdraw_from_deposit(deposit_id, amount)
                )
                withdraw_button.pack(pady=10)

                # Кнопка для пополнения депозита со счета
                add_button = ctk.CTkButton(
                    self.main_frame,
                    text="Add to Deposit",
                    command=lambda: self.add_to_deposit(deposit_id)
                )
                add_button.pack(pady=10)

                # Кнопка для закрытия депозита (если баланс = 0)
                if amount == 0:
                    close_button = ctk.CTkButton(
                        self.main_frame,
                        text="Close Deposit",
                        command=lambda: self.close_deposit(deposit_id)
                    )
                    close_button.pack(pady=10)
                else:
                    warning_label = ctk.CTkLabel(
                        self.main_frame,
                        text="You can close the deposit only if the balance is 0.",
                        font=("Arial", 12),
                        fg_color="red"
                    )
                    warning_label.pack(pady=10)
            else:  # Если депозита нет, показываем кнопку "Открыть депозит"
                no_deposit_label = ctk.CTkLabel(self.main_frame, text="No active deposit found.")
                no_deposit_label.pack(pady=10)

                open_button = ctk.CTkButton(
                    self.main_frame,
                    text="Open Deposit",
                    command=self.open_deposit
                )
                open_button.pack(pady=10)

        except Exception as e:
            error_label = ctk.CTkLabel(self.main_frame, text=f"Error fetching deposit: {e}")
            error_label.pack(pady=20)

        # Кнопка возврата
        back_button = ctk.CTkButton(
            self.main_frame,
            text="Back to menu",
            command=lambda: self.show_bank_frame(self.current_customer_id)
        )
        back_button.pack(pady=10)

    # Функция для открытия нового депозита
    def open_deposit(self):
        """Создает новый депозит для текущего аккаунта."""
        try:
            cursor = self.conn.cursor()

            # Стартовые параметры депозита
            interest_rate = 3.5  # Например, фиксированная ставка
            initial_amount = simpledialog.askfloat("Open Deposit", "Enter initial deposit amount:")

            if initial_amount is None or initial_amount <= 0:
                messagebox.showwarning("Invalid Amount", "Deposit amount must be greater than 0.")
                return

            query = """
                INSERT INTO deposit (account, interest_rate, amount)
                VALUES (?, ?, ?)
            """
            cursor.execute(query, (self.current_account_number, interest_rate, initial_amount))
            self.conn.commit()

            messagebox.showinfo("Success", "Deposit successfully opened!")
            self.show_deposit_frame()
        except Exception as e:
            messagebox.showerror("Error", f"Error opening deposit: {e}")

    def withdraw_from_deposit(self, deposit_id, amount):
        """Перевод средств с депозита на счет."""
        if amount <= 0:
            messagebox.showerror("Error", "There are not enough funds on the deposit to withdraw.")
            return

        try:
            cursor = self.conn.cursor()
            query = "UPDATE deposit SET amount = 0 WHERE deposit_id = ?"
            cursor.execute(query, (deposit_id,))
            self.conn.commit()

            # Обновляем баланс основного счета
            update_account = """
                UPDATE accounts
                SET balance = balance + ?
                WHERE account_number = ?
            """
            cursor.execute(update_account, (amount, self.current_account_number))
            self.conn.commit()

            messagebox.showinfo("Successfully", "Funds have been successfully transferred to your account.")
        except Exception as e:
            messagebox.showerror("Error", f"Money transfer error: {e}")

    def add_to_deposit(self, deposit_id):
        """Пополнение депозита со счета."""
        amount = simpledialog.askfloat("Deposit replenishment", "Enter the amount:")
        if not amount or amount <= 0:
            messagebox.showerror("Error", "Enter the correct amount.")
            return

        try:
            cursor = self.conn.cursor()

            # Проверяем баланс основного счета
            check_balance = """
                SELECT balance FROM accounts WHERE account_number = ?
            """
            cursor.execute(check_balance, (self.current_account_number,))
            account_balance = cursor.fetchone()[0]

            if amount > account_balance:
                messagebox.showerror("Error", "Insufficient funds in the main account.")
                return

            # Списываем сумму с основного счета
            update_account = """
                UPDATE accounts
                SET balance = balance - ?
                WHERE account_number = ?
            """
            cursor.execute(update_account, (amount, self.current_account_number))

            # Добавляем сумму на депозит
            update_deposit = """
                UPDATE deposit
                SET amount = amount + ?
                WHERE deposit_id = ?
            """
            cursor.execute(update_deposit, (amount, deposit_id))
            self.conn.commit()

            messagebox.showinfo("Successfully", "The deposit has been successfully replenished.")
        except Exception as e:
            messagebox.showerror("Error", f"Deposit replenishment error: {e}")

    def close_deposit(self, deposit_id, amount):
        """Закрытие депозита (доступно, если баланс депозита 0)."""
        if amount > 0:
            messagebox.showerror("Error", "You cannot close the deposit while there are funds on it.")
            return

        try:
            cursor = self.conn.cursor()
            query = "DELETE FROM deposit WHERE deposit_id = ?"
            cursor.execute(query, (deposit_id,))
            self.conn.commit()

            messagebox.showinfo("Successfully", "The deposit has been successfully closed.")
        except Exception as e:
            messagebox.showerror("Error", f"Deposit closing error: {e}")

    def show_credit_frame(self):
        """Отображает фрейм для управления кредитами."""
        self.clear_frame()

        # Заголовок
        label = ctk.CTkLabel(self.main_frame, text="Manage Credits", font=("Arial", 20))
        label.pack(pady=20)

        # Подключение к базе данных, чтобы получить текущий активный кредит
        try:
            cursor = self.conn.cursor()
            query = """
                SELECT credit_id, credit_amount, interest_rate, start_date, end_date, mounthly_payment, remaining_balance, credit_status
                FROM credit
                WHERE customer_id = ? AND credit_status = 'active'
            """
            cursor.execute(query, (self.current_customer_id,))
            credit = cursor.fetchone()

            if credit:
                credit_id, amount, rate, start_date, end_date, monthly_payment, balance, status = credit

                # Информация о текущем кредите
                credit_info = ctk.CTkLabel(
                    self.main_frame,
                    text=(
                        f"Credit Amount: {amount:.2f} USD\n"
                        f"Interest Rate: {rate:.2f}%\n"
                        f"Start Date: {start_date}\n"
                        f"End Date: {end_date}\n"
                        f"Monthly Payment: {monthly_payment:.2f} USD\n"
                        f"Remaining Balance: {balance:.2f} USD\n"
                        f"Status: {status}"
                    ),
                    font=("Arial", 14),
                    anchor="w"
                )
                credit_info.pack(pady=10)

                # Кнопка для погашения кредита
                pay_button = ctk.CTkButton(
                    self.main_frame,
                    text="Make Payment",
                    command=lambda: self.make_credit_payment(credit_id, balance)
                )
                pay_button.pack(pady=5)
            else:
                no_credit_label = ctk.CTkLabel(self.main_frame, text="No active credits found.")
                no_credit_label.pack(pady=20)

        except Exception as e:
            error_label = ctk.CTkLabel(self.main_frame, text=f"Error fetching credits: {e}")
            error_label.pack(pady=20)

        # Кнопка для подачи заявки на новый кредит
        new_credit_button = ctk.CTkButton(
            self.main_frame,
            text="Apply for New Credit",
            command=self.apply_for_credit
        )
        new_credit_button.pack(pady=10)

        # Кнопка возврата
        back_button = ctk.CTkButton(
            self.main_frame,
            text="Back to menu",
            command=lambda: self.show_bank_frame(self.current_customer_id)
        )
        back_button.pack(pady=10)

    def apply_for_credit(self):
        """Отображает окно для подачи заявки на новый кредит."""
        credit_amount = simpledialog.askfloat("Credit Application", "Enter credit amount:")
        if not credit_amount or credit_amount <= 0:
            messagebox.showerror("Error", "Incorrect loan amount.")
            return

        try:
            cursor = self.conn.cursor()
            interest_rate = 5.0  # Пример фиксированной ставки
            duration_months = 12  # Пример фиксированного срока кредита
            monthly_payment = (credit_amount * (1 + (interest_rate / 100))) / duration_months

            # Проверка, есть ли уже активный кредит
            query_active_credit = "SELECT credit_id FROM credit WHERE customer_id = ? AND credit_status = 'active'"
            cursor.execute(query_active_credit, (self.current_customer_id,))
            active_credit = cursor.fetchone()

            if active_credit:
                messagebox.showerror("Error", "You already have an active loan. Pay it off before making a new one.")
                return

            # Оформление нового кредита
            query_credit = """
                INSERT INTO credit (customer_id, credit_amount, interest_rate, start_date, end_date, mounthly_payment, remaining_balance, credit_status)
                VALUES (?, ?, ?, GETDATE(), DATEADD(MONTH, ?, GETDATE()), ?, ?, 'active')
            """
            cursor.execute(
                query_credit,
                (
                    self.current_customer_id,
                    credit_amount,
                    interest_rate,
                    duration_months,
                    monthly_payment,
                    credit_amount  # Первоначальный остаток равен полной сумме
                )
            )
            self.conn.commit()

            # Обновление баланса пользователя
            query_balance = """
                UPDATE accounts
                SET balance = balance + ?
                WHERE customer_id = ? AND is_active = 1
            """
            cursor.execute(query_balance, (credit_amount, self.current_customer_id))
            self.conn.commit()


            messagebox.showinfo("Successfully", "The loan has been successfully issued.")
            self.show_credit_frame()
        except Exception as e:
            messagebox.showerror("Error", f"Loan processing error: {e}")

    def make_credit_payment(self, credit_id, remaining_balance):
        """Обрабатывает платеж по кредиту."""
        payment_amount = simpledialog.askfloat("Make Payment", "Enter payment amount:")
        if not payment_amount or payment_amount <= 0:
            messagebox.showerror("Error", "Incorrect payment amount.")
            return

        try:
            cursor = self.conn.cursor()

            # Проверка текущего баланса пользователя
            query_balance = "SELECT balance FROM accounts WHERE customer_id = ? AND is_active = 1"
            cursor.execute(query_balance, (self.current_customer_id,))
            current_balance = cursor.fetchone()[0]

            if payment_amount > current_balance:
                messagebox.showerror("Error", "The payment amount exceeds your current balance.")
                return

            if payment_amount > remaining_balance:
                messagebox.showerror("Error", "The payment amount exceeds the loan balance.")
                return

            # Вычитание суммы платежа из баланса
            query_update_balance = """
                UPDATE accounts
                SET balance = balance - ?
                WHERE customer_id = ? AND is_active = 1
            """
            cursor.execute(query_update_balance, (payment_amount, self.current_customer_id))

            # Обновление остатка по кредиту
            query_update_credit = """
                UPDATE credit
                SET remaining_balance = remaining_balance - ?
                WHERE credit_id = ?
            """
            cursor.execute(query_update_credit, (payment_amount, credit_id))

            # Проверка остатка по кредиту
            query_check_balance = "SELECT remaining_balance FROM credit WHERE credit_id = ?"
            cursor.execute(query_check_balance, (credit_id,))
            new_balance = cursor.fetchone()[0]
            if new_balance == 0:
                query_close_credit = "UPDATE credit SET credit_status = 'closed' WHERE credit_id = ?"
                cursor.execute(query_close_credit, (credit_id,))

            self.conn.commit()

            messagebox.showinfo("Successfully", "The payment was completed successfully.")
            self.show_credit_frame()
        except Exception as e:
            messagebox.showerror("Error", f"Payment execution error: {e}")

    def change_appearance_mode_event(self, new_appearance_mode: str):
        customtkinter.set_appearance_mode(new_appearance_mode)

    def show_employee_frame(self, employee_id):
        """Отображает интерфейс для сотрудников банка."""
        self.clear_frame()

        # Заголовок
        title_label = ctk.CTkLabel(
            self.main_frame,
            text="Employee Dashboard",
            font=("Arial", 24, "bold")
        )
        title_label.pack(pady=(20, 10))

        # Операционные кнопки
        buttons_frame = ctk.CTkFrame(self.main_frame, corner_radius=8)
        buttons_frame.pack(pady=20, padx=20, fill="x")

        buttons = [
            ("View Active Credits", self.show_active_credits),
            ("Manage Accounts", self.manage_accounts),
            ("Credit Report", self.generate_credit_report),
            ("Manage Employees", self.manage_employee_accounts),
            ("Fraud Detection", self.fraud_detection)
        ]

        for text, command in buttons:
            button = ctk.CTkButton(
                buttons_frame,
                text=text,
                command=command
            )
            button.pack(pady=5)

        # Кнопка выхода
        logout_button = ctk.CTkButton(
            self.main_frame,
            text="Log Out",
            command=self.show_login_frame
        )
        logout_button.pack(pady=20)

    def show_active_credits(self):
        """Отображает список активных кредитов."""
        self.clear_frame()

        # Заголовок
        label = ctk.CTkLabel(self.main_frame, text="Active Credits", font=("Arial", 18))
        label.pack(pady=20)

        try:
            cursor = self.conn.cursor()
            query = """
                SELECT credit_id, customer_id, credit_amount, interest_rate, start_date, remaining_balance
                FROM credit
                WHERE credit_status = 'active'
            """
            cursor.execute(query)
            credits = cursor.fetchall()

            if credits:
                for credit in credits:
                    credit_id, customer_id, amount, rate, start_date, balance = credit
                    credit_info = ctk.CTkLabel(
                        self.main_frame,
                        text=(
                            f"Credit ID: {credit_id}\n"
                            f"Customer ID: {customer_id}\n"
                            f"Amount: {amount:.2f} USD\n"
                            f"Interest Rate: {rate:.2f}%\n"
                            f"Start Date: {start_date}\n"
                            f"Remaining Balance: {balance:.2f} USD"
                        ),
                        font=("Arial", 14),
                        anchor="w"
                    )
                    credit_info.pack(pady=10)
            else:
                no_credits_label = ctk.CTkLabel(self.main_frame, text="No active credits found.")
                no_credits_label.pack(pady=20)
        except Exception as e:
            error_label = ctk.CTkLabel(self.main_frame, text=f"Error fetching active credits: {e}")
            error_label.pack(pady=20)

        # Кнопка возврата
        back_button = ctk.CTkButton(self.main_frame, text="Back",
                                    command=lambda: self.show_employee_frame(self.current_employee_id))
        back_button.pack(pady=10)

    def manage_accounts(self):
        """Позволяет сотруднику управлять банковскими счетами клиентов."""
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Manage Accounts", font=("Arial", 18))
        label.pack(pady=20)

        # Пример интерфейса: выбор действия
        actions = [
            ("Create Account", self.create_account),
            ("Block Account", self.block_account),
            ("Delete Account", self.delete_account)
        ]

        for text, command in actions:
            button = ctk.CTkButton(self.main_frame, text=text, command=command)
            button.pack(pady=5)

        # Кнопка возврата
        back_button = ctk.CTkButton(self.main_frame, text="Back",
                                    command=lambda: self.show_employee_frame(self.current_employee_id))
        back_button.pack(pady=10)

    def create_account(self):
        """Логика создания нового счета клиента."""
        messagebox.showinfo("Create Account", "The account creation function has not been implemented yet.")

    def block_account(self):
        """Логика блокировки счета клиента."""
        messagebox.showinfo("Block Account", "The account blocking feature has not yet been implemented.")

    def delete_account(self):
        """Логика удаления счета клиента."""
        messagebox.showinfo("Delete Account", "The account deletion feature has not yet been implemented.")

    def start_fraud_detection(self):
        threading.Thread(target=self.fraud_detection).start()

    def prepare_data_for_prediction(self, data):
        """Подготовка данных для модели (например, масштабирование, преобразования)."""

        # Приведение всех имён столбцов к формату, который ожидался моделью
        data = data.rename(columns={
            'oldBalanceOrig': 'oldBalanceOrig',
            'newBalanceOrig': 'newBalanceOrig',
            'oldBalanceDest': 'oldBalanceDest',
            'newBalanceDest': 'newBalanceDest',
            'amount': 'amount'
        })

        # Заполнение пропусков (если есть)
        data = data.fillna(0)

        # Применение Box-Cox с проверкой на константность
        for col in ['amount', 'oldBalanceOrig', 'newBalanceOrig', 'oldBalanceDest', 'newBalanceDest']:
            if len(np.unique(data[col])) == 1:  # Если все значения в столбце одинаковы
                print(f"Column {col} is constant. Skipping Box-Cox transformation.")
                data[f"{col}_boxcox"] = data[col]  # Копируем значения без изменений
            else:
                data[f"{col}_boxcox"], _ = boxcox(data[col] + 1)  # Добавляем 1, чтобы избежать проблем с нулями

        # Выделение признаков для модели
        feature_names = ['amount_boxcox', 'oldBalanceOrig_boxcox', 'newBalanceOrig_boxcox',
                         'oldBalanceDest_boxcox', 'newBalanceDest_boxcox']
        X = data[feature_names]

        # Выделение идентификаторов транзакций (для последующего обновления в БД)
        transaction_ids = data['transaction_id']

        return X, transaction_ids

    def fraud_detection(self):
        """Проверяет транзакции на мошенничество с использованием обученной модели."""

        if not hasattr(self, 'current_employee_id') or self.current_employee_id is None:
            print("Employee ID is not set. Please log in as an employee.")
            return

        # Параметры подключения к базе данных
        server = 'DESKTOP-3T1O5TL'
        database = 'BankAppDB'
        driver = 'ODBC Driver 18 for SQL Server'

        connection_str = (
                f"mssql+pyodbc:///?odbc_connect="
                + quote_plus(
            f"DRIVER={{{driver}}};"
            f"SERVER={server};"
            f"DATABASE={database};"
            "ENCRYPT=yes;"
            "TrustServerCertificate=yes;"
            "Trusted_Connection=yes;"
        )
        )

        try:
            # Создание SQLAlchemy-движка
            engine = create_engine(connection_str)

            # Извлечение данных из базы
            query = """
            SELECT transaction_id, account_from, account_to, oldBalanceOrig, newBalanceOrig, 
                   oldBalanceDest, newBalanceDest, amount, isFlaggedFraud
            FROM transactions
            WHERE status = 'pending'
            """
            data = pd.read_sql(query, engine)

            # Проверка, если данных нет
            if data.empty:
                print("No pending transactions found.")
                return

            # Подготовка данных для модели
            X, transaction_ids = self.prepare_data_for_prediction(data)

            # Загрузка модели
            try:
                logreg = joblib.load('C:/Users/Админ/OneDrive/Documents/3 курс курсовая/fraud_detection_model.pkl')
            except Exception as e:
                print(f"Error loading model: {e}")
                return

            # Прогнозирование мошенничества
            predictions = logreg.predict(X)
            prediction_probabilities = logreg.predict_proba(X)[:, 1]

            # Обновление базы данных с результатами
            try:
                with engine.begin() as connection:
                    update_query = text("""
                        UPDATE transactions
                        SET isFlaggedFraud = :isFlaggedFraud, status = 'completed', employee_id = :employee_id
                        WHERE transaction_id = :transaction_id AND status = 'pending'
                    """)

                    account_update_query = text("""
                        UPDATE accounts
                        SET balance = :new_balance
                        WHERE account_number = :account_number
                    """)

                    for transaction_id, prediction, prob, account_from, account_to, new_balance_orig, new_balance_dest in zip(
                            transaction_ids, predictions, prediction_probabilities, data['account_from'],
                            data['account_to'], data['newBalanceOrig'], data['newBalanceDest']):
                        is_fraud = int(prediction)
                        if prob < 0.9:
                            is_fraud = 0  # Честная транзакция

                        # Обновление статуса транзакции и запись ID сотрудника
                        connection.execute(update_query, {
                            'isFlaggedFraud': is_fraud,
                            'transaction_id': transaction_id,
                            'employee_id': self.current_employee_id
                        })

                        # Обновление баланса для отправителя
                        connection.execute(account_update_query, {
                            'new_balance': new_balance_orig,
                            'account_number': account_from
                        })

                        # Обновление баланса для получателя
                        connection.execute(account_update_query, {
                            'new_balance': new_balance_dest,
                            'account_number': account_to
                        })
                        fraudulent_count = sum(predictions)
            except Exception as e:
                print(f"Error during fraud detection process: {e}")
            print(f"Fraud detection completed: {fraudulent_count} fraudulent transactions flagged.")
        except Exception as e:
            print(f"Error during fraud detection process: {e}")

    def generate_credit_report(self):
        """Отображает сводную статистику по кредитам."""
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Credit Report", font=("Arial", 18))
        label.pack(pady=20)

        try:
            cursor = self.conn.cursor()
            query = """
                SELECT credit_status, COUNT(*), SUM(credit_amount)
                FROM credit
                GROUP BY credit_status
            """
            cursor.execute(query)
            report = cursor.fetchall()

            if report:
                for status, count, total in report:
                    report_info = ctk.CTkLabel(
                        self.main_frame,
                        text=(
                            f"Status: {status}\n"
                            f"Count: {count}\n"
                            f"Total Amount: {total:.2f} USD"
                        ),
                        font=("Arial", 14),
                        anchor="w"
                    )
                    report_info.pack(pady=10)
            else:
                no_report_label = ctk.CTkLabel(self.main_frame, text="No data available.")
                no_report_label.pack(pady=20)
        except Exception as e:
            error_label = ctk.CTkLabel(self.main_frame, text=f"Error generating report: {e}")
            error_label.pack(pady=20)

        # Кнопка возврата
        back_button = ctk.CTkButton(self.main_frame, text="Back",
                                    command=lambda: self.show_employee_frame(self.current_employee_id))
        back_button.pack(pady=10)

    def manage_employee_accounts(self):
        """Управляет учетными записями сотрудников."""
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Manage Employee Accounts", font=("Arial", 18))
        label.pack(pady=20)

        # Пример интерфейса
        actions = [
            ("Add Employee", self.add_employee),
            ("Remove Employee", self.remove_employee)
        ]

        for text, command in actions:
            button = ctk.CTkButton(self.main_frame, text=text, command=command)
            button.pack(pady=5)

        # Кнопка возврата
        back_button = ctk.CTkButton(self.main_frame, text="Back",
                                    command=lambda: self.show_employee_frame(self.current_employee_id))
        back_button.pack(pady=10)

    def add_employee(self):
        """Добавляет нового сотрудника в базу данных."""
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Add Employee", font=("Arial", 18))
        label.pack(pady=20)

        # Поля ввода данных для нового сотрудника
        firstname_label = ctk.CTkLabel(self.main_frame, text="First Name:")
        firstname_label.pack()
        firstname_entry = ctk.CTkEntry(self.main_frame)
        firstname_entry.pack()

        lastname_label = ctk.CTkLabel(self.main_frame, text="Last Name:")
        lastname_label.pack()
        lastname_entry = ctk.CTkEntry(self.main_frame)
        lastname_entry.pack()

        phone_label = ctk.CTkLabel(self.main_frame, text="Phone:")
        phone_label.pack()
        phone_entry = ctk.CTkEntry(self.main_frame)
        phone_entry.pack()

        password_label = ctk.CTkLabel(self.main_frame, text="Password:")
        password_label.pack()
        password_entry = ctk.CTkEntry(self.main_frame, show="*")
        password_entry.pack()

        def save_employee():
            firstname = firstname_entry.get()
            lastname = lastname_entry.get()
            phone = phone_entry.get()
            password = password_entry.get()

            if not (firstname and lastname and phone and password):
                messagebox.showerror("Error", "All fields are required.")
                return

            try:
                cursor = self.conn.cursor()
                query = """
                    INSERT INTO employees (firstname, lastname, phone, password)
                    VALUES (?, ?, ?, ?)
                """
                cursor.execute(query, (firstname, lastname, phone, password))
                self.conn.commit()
                messagebox.showinfo("Success", "Employee added successfully.")
                self.manage_employee_accounts()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to add employee: {e}")

        # Кнопка сохранения
        save_button = ctk.CTkButton(self.main_frame, text="Save", command=save_employee)
        save_button.pack(pady=10)

        # Кнопка возврата
        back_button = ctk.CTkButton(self.main_frame, text="Back",
                                    command=self.manage_employee_accounts)
        back_button.pack(pady=10)

    def remove_employee(self):
        """Удаляет сотрудника из базы данных."""
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Remove Employee", font=("Arial", 18))
        label.pack(pady=20)

        # Поле ввода ID сотрудника
        employee_id_label = ctk.CTkLabel(self.main_frame, text="Enter Employee ID:")
        employee_id_label.pack(pady=5)
        employee_id_entry = ctk.CTkEntry(self.main_frame)
        employee_id_entry.pack(pady=5)

        def confirm_removal():
            employee_id = employee_id_entry.get()
            if not employee_id.isdigit():
                messagebox.showerror("Error", "Employee ID must be a number.")
                return

            try:
                cursor = self.conn.cursor()
                # Проверяем, существует ли сотрудник
                check_query = "SELECT COUNT(*) FROM employees WHERE employee_id = ?"
                cursor.execute(check_query, (int(employee_id),))
                exists = cursor.fetchone()[0]
                if not exists:
                    messagebox.showerror("Error", "Employee ID not found.")
                    return

                # Удаление сотрудника
                delete_query = "DELETE FROM employees WHERE employee_id = ?"
                cursor.execute(delete_query, (int(employee_id),))
                self.conn.commit()
                messagebox.showinfo("Success", "Employee removed successfully.")
                self.manage_employee_accounts()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to remove employee: {e}")

        # Кнопка подтверждения
        confirm_button = ctk.CTkButton(self.main_frame, text="Remove", command=confirm_removal)
        confirm_button.pack(pady=10)

        # Кнопка возврата
        back_button = ctk.CTkButton(self.main_frame, text="Back", command=self.manage_employee_accounts)
        back_button.pack(pady=10)

    def clear_frame(self):
        """Очищает текущий фрейм."""
        for widget in self.main_frame.winfo_children():
            widget.destroy()


# Запуск приложения
if __name__ == "__main__":
    app = AppBank()
    app.mainloop()
