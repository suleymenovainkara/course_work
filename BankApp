import customtkinter
import customtkinter as ctk
import pyodbc
import sys
from tkinter import messagebox
import requests
import random
from tkinter import simpledialog
import datetime
from decimal import Decimal
import pandas as pd
import joblib
from scipy.stats import boxcox
import numpy as np
from urllib.parse import quote_plus
import threading
from sqlalchemy import create_engine, text

server = 'DESKTOP-3T1O5TL'
database = 'BankAppDB'

connection_str = (
    f"DRIVER={{ODBC Driver 18 for SQL Server}};"
    f"SERVER={server};"
    f"DATABASE={database};"
    "ENCRYPT=yes;"
    "TrustServerCertificate=yes;"
    "Trusted_Connection=yes;"
)

class AppBank(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Bank Application")
        self.geometry("800x600")

        try:
            self.conn = pyodbc.connect(connection_str)
        except pyodbc.Error as e:
            messagebox.showerror("Connection error", f"Failed to connect to the database: {e}")
            sys.exit(1)
        self.main_frame = ctk.CTkFrame(self, width=800, height=600)
        self.main_frame.pack(fill="both", expand=True)

        customtkinter.set_default_color_theme("green")

        self.show_login_frame()

    def show_login_frame(self):
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Login to Bank Application", font=("Arial", 25, "bold"))
        label.place(relx=0.5, rely=0.1, anchor="center")  # Центрируем

        self.phone_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Phone")
        self.phone_entry.place(relx=0.5, rely=0.3, anchor="center")  # Центрируем

        self.password_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Password", show="*")
        self.password_entry.place(relx=0.5, rely=0.4, anchor="center")

        login_button = ctk.CTkButton(self.main_frame, text="Login", command=self.login_user)
        login_button.place(relx=0.5, rely=0.5, anchor="center")

        register_button = ctk.CTkButton(self.main_frame, text="Register", command=self.show_register_frame)
        register_button.place(relx=0.5, rely=0.6, anchor="center")

        appearance_label = ctk.CTkLabel(self.main_frame, text="Appearance Mode:", font=("Arial", 12))
        appearance_label.place(relx=0.4, rely=0.7, anchor="center")

        appearance_menu = ctk.CTkOptionMenu(self.main_frame,
                                            values=["Light", "Dark"],
                                            command=self.change_appearance_mode_event)
        appearance_menu.place(relx=0.6, rely=0.7, anchor="center")

    def show_register_frame(self):
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Register New Account", font=("Arial", 20))
        label.pack(pady=20)
        self.first_name_entry = ctk.CTkEntry(self.main_frame, placeholder_text="First Name")
        self.first_name_entry.pack(pady=10)
        self.last_name_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Last Name")
        self.last_name_entry.pack(pady=10)
        self.phone_register_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Phone")
        self.phone_register_entry.pack(pady=10)
        self.dob_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Date of Birth (YYYY-MM-DD)")
        self.dob_entry.pack(pady=10)
        self.gender_var = ctk.StringVar(value="Select Gender")  # Переменная для хранения выбранного значения
        self.gender_menu = ctk.CTkOptionMenu(self.main_frame, variable=self.gender_var,
                                             values=["Male", "Female", "Other"])
        self.gender_menu.pack(pady=10)
        self.password_register_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Password", show="*")
        self.password_register_entry.pack(pady=10)

        register_button = ctk.CTkButton(self.main_frame, text="Register", command=self.register_user)
        register_button.pack(pady=10)

        back_button = ctk.CTkButton(self.main_frame, text="Back to Login", command=self.show_login_frame)
        back_button.pack(pady=10)

    def login_user(self):
        phone = self.phone_entry.get()
        password = self.password_entry.get()

        if not phone or not password:
            messagebox.showerror("Error", "Enter your phone and password")
            return

        cursor = self.conn.cursor()

        employee_query = "SELECT employee_id, firstname, lastname FROM employees WHERE phone = ? AND password = ?"
        cursor.execute(employee_query, (phone, password))
        employee = cursor.fetchone()

        if employee:
            employee_id, firstname, lastname = employee
            messagebox.showinfo("Successfully", f"Welcome, {firstname} {lastname}! (Employee)")

            self.current_employee_id = employee_id

            self.show_employee_frame(employee_id)
            return

        customer_query = "SELECT customer_id, first_name, last_name FROM customer WHERE phone = ? AND password = ?"
        cursor.execute(customer_query, (phone, password))
        customer = cursor.fetchone()

        if customer:
            customer_id, first_name, last_name = customer
            messagebox.showinfo("Successfully", f"Welcome, {first_name} {last_name}!")

            self.current_customer_id = customer_id

            account_query = "SELECT account_number FROM accounts WHERE customer_id = ?"
            cursor.execute(account_query, (self.current_customer_id,))
            account = cursor.fetchone()

            if account:
                self.current_account_number = account[0]
            else:
                self.current_account_number = None
                messagebox.showwarning("Attention", "The user does not have an active account.")

            self.show_bank_frame(customer_id)
            return

        messagebox.showerror("Error", "Invalid phone number or password")

    def register_user(self):
        first_name = self.first_name_entry.get()
        last_name = self.last_name_entry.get()
        phone = self.phone_register_entry.get()
        dob = self.dob_entry.get()
        gender = self.gender_var.get()
        password = self.password_register_entry.get()

        if not all([first_name, last_name, phone, dob, password]) or gender == "Select Gender":
            messagebox.showerror("Error", "Fill in all the fields and select the gender!")
            return

        if not (phone.startswith("+7") and len(phone) == 12 and phone[1:].isdigit()):
            messagebox.showerror("Error", "Enter the correct phone number in the format +7XXXXXXXXXX!")
            return

        account_number = self.generate_account_number()

        cursor = self.conn.cursor()
        try:
            query_customer = """
            INSERT INTO customer (first_name, last_name, phone, date_of_birth, gender, [password])
            OUTPUT INSERTED.customer_id
            VALUES (?, ?, ?, ?, ?, ?)
            """
            cursor.execute(query_customer, (first_name, last_name, phone, dob, gender, password))

            customer_id = cursor.fetchone()[0]

            query_account = """
            INSERT INTO accounts (account_number, customer_id)
            VALUES (?, ?)
            """
            cursor.execute(query_account, (account_number, customer_id))
            self.conn.commit()

            messagebox.showinfo(
                "Successfully",
                f"You have successfully registered! Your account number: {account_number}"
            )
            self.show_login_frame()
        except pyodbc.Error as e:
            self.conn.rollback()
            messagebox.showerror("Error", f"Failed to register: {e}")

    def generate_account_number(self):

        while True:
            account_number = f"4400{''.join(str(random.randint(0, 9)) for _ in range(8))}"

            cursor = self.conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM accounts WHERE account_number = ?", (account_number,))
            if cursor.fetchone()[0] == 0:
                return account_number

    def show_bank_frame(self, customer_id):

        self.clear_frame()

        title_label = ctk.CTkLabel(
            self.main_frame,
            text="My Bank",
            font=("Arial", 24, "bold")
        )
        title_label.pack(pady=(20, 10))

        cursor = self.conn.cursor()
        query_balance = "SELECT balance, currency FROM accounts WHERE customer_id = ? AND is_active = 1"
        cursor.execute(query_balance, (customer_id,))
        account = cursor.fetchone()

        if account:
            balance, currency = account

            balance_frame = ctk.CTkFrame(self.main_frame, border_width=2, corner_radius=8)
            balance_frame.pack(pady=10, padx=20, fill="x")

            balance_label = ctk.CTkLabel(
                balance_frame,
                text=f"Balance: {balance:.2f} {currency}",
                font=("Arial", 16)
            )
            balance_label.pack(pady=10)
        else:
            balance_label = ctk.CTkLabel(
                self.main_frame,
                text="No active account found",
                font=("Arial", 14, "italic")
            )
            balance_label.pack(pady=10)
            return
        try:
            response = requests.get("https://api.exchangerate-api.com/v4/latest/USD")
            data = response.json()
            rates = data["rates"]
            allowed_currencies = ["USD", "RUB", "KZT", "CHF", "GBP", "CNY", "EUR"]
            filtered_rates = {code: rate for code, rate in rates.items() if code in allowed_currencies}

            rates_frame = ctk.CTkFrame(self.main_frame, border_width=2, corner_radius=8)
            rates_frame.pack(pady=10, padx=20, anchor="center")

            rates_label = ctk.CTkLabel(
                rates_frame,
                text="Exchange Rates",
                font=("Arial", 16, "bold")
            )
            rates_label.pack(pady=(10, 5))

            rates_row_frame = ctk.CTkFrame(rates_frame)
            rates_row_frame.pack(pady=(5, 10), padx=10, fill="x")

            for code, rate in filtered_rates.items():
                rate_label = ctk.CTkLabel(
                    rates_row_frame,
                    text=f"{code}: {rate:.2f}",
                    font=("Arial", 12)
                )
                rate_label.pack(side="left", padx=10)  # Размещаем все курсы в строку
        except Exception as e:
            error_label = ctk.CTkLabel(
                self.main_frame,
                text=f"Failed to fetch currency rates: {e}",
                font=("Arial", 12, "italic"),
                text_color="red"
            )
            error_label.pack(pady=10)

        buttons_frame = ctk.CTkFrame(self.main_frame, corner_radius=8)
        buttons_frame.pack(pady=20, padx=20, fill="x")

        buttons = [
            ("Transaction", self.show_transaction_frame),
            ("Deposit", self.show_deposit_frame),
            ("Credit", self.show_credit_frame),
            ("Stocks", self.show_stocks_frame)
        ]

        for text, command in buttons:
            button = ctk.CTkButton(
                buttons_frame,
                text=text,
                command=command
            )
            button.pack(pady=5)

        logout_button = ctk.CTkButton(
            self.main_frame,
            text="Logout",
            command=self.show_login_frame
        )
        logout_button.pack(pady=20)

    def show_transaction_frame(self):
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="New Transaction", font=("Arial", 20))
        label.pack(pady=20)

        target_account_label = ctk.CTkLabel(self.main_frame, text="Target Account (12 digits):")
        target_account_label.pack(pady=5)
        self.target_account_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Enter account number")
        self.target_account_entry.pack(pady=5)

        amount_label = ctk.CTkLabel(self.main_frame, text="Amount:")
        amount_label.pack(pady=5)
        self.amount_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Enter amount")
        self.amount_entry.pack(pady=5)

        description_label = ctk.CTkLabel(self.main_frame, text="Description (optional):")
        description_label.pack(pady=5)
        self.description_entry = ctk.CTkEntry(self.main_frame, placeholder_text="Enter description")
        self.description_entry.pack(pady=5)

        transfer_button = ctk.CTkButton(
            self.main_frame, text="Make Transfer", command=self.perform_transaction
        )
        transfer_button.pack(pady=20)

        back_button = ctk.CTkButton(
            self.main_frame,
            text="Back to menu",
            command=lambda: self.show_bank_frame(self.current_customer_id)
        )
        back_button.pack(pady=10)

    def perform_transaction(self):
        target_account = self.target_account_entry.get()
        amount = self.amount_entry.get()
        description = self.description_entry.get()

        if not target_account or not amount:
            messagebox.showerror("Error", "Enter the account number and amount")
            return

        try:
            amount = Decimal(amount)  # Используем Decimal вместо float
            if amount <= 0:
                raise ValueError("The amount must be positive")
        except Exception as e:
            messagebox.showerror("Error", f"Incorrect amount: {e}")
            return

        if not (target_account.startswith("4400") and len(target_account) == 12):
            messagebox.showerror("Error", "Invalid target account format")
            return

        try:
            cursor = self.conn.cursor()

            cursor.execute(
                "SELECT balance FROM accounts WHERE account_number = ?",
                (self.current_account_number,)
            )
            sender_balance = cursor.fetchone()
            if sender_balance is None:
                messagebox.showerror("Error", "The sender's account was not found")
                return

            sender_balance = sender_balance[0]
            if sender_balance < amount:
                messagebox.showerror("Error", "Insufficient funds in the account")
                return

            cursor.execute(
                "SELECT balance FROM accounts WHERE account_number = ?",
                (target_account,)
            )
            target_account_balance = cursor.fetchone()
            if target_account_balance is None:
                messagebox.showerror("Error", "The target account was not found")
                return

            target_account_balance = target_account_balance[0]

            new_sender_balance = sender_balance - amount
            new_target_balance = target_account_balance + amount

            transaction_date = datetime.datetime.now()
            start_date = datetime.datetime(transaction_date.year, transaction_date.month, 1)
            step = (transaction_date - start_date).days * 24 + (transaction_date - start_date).seconds // 3600

            cursor.execute(
                """
                INSERT INTO transactions (
                    account_from, account_to, amount, transaction_type, description, status, 
                    oldBalanceOrig, newBalanceOrig, oldBalanceDest, newBalanceDest, isFlaggedFraud, transaction_date
                )
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    self.current_account_number,
                    target_account,
                    amount,
                    "Transfer",
                    description,
                    "pending",
                    sender_balance,
                    new_sender_balance,
                    target_account_balance,
                    new_target_balance,
                    0,
                    transaction_date
                )
            )

            # Сохранение изменений
            self.conn.commit()
            messagebox.showinfo("Successfully", f"The transaction was created with the status 'pending'. Step: {step}")

        except Exception as e:
            self.conn.rollback()  # Откат изменений в случае ошибки
            messagebox.showerror("Error", f"Transaction execution error: {e}")

    def show_stocks_frame(self):
        self.clear_frame()

        title_label = ctk.CTkLabel(
            self.main_frame,
            text="Top 10 Exchanges",
            font=("Arial", 24, "bold")
        )
        title_label.pack(pady=(20, 10))

        try:
            response = requests.get("https://api.coingecko.com/api/v3/exchanges")
            data = response.json()

            top_exchanges = data[:10]

            exchanges_frame = ctk.CTkFrame(self.main_frame, border_width=2, corner_radius=8)
            exchanges_frame.pack(pady=10, padx=10, fill="both", expand=True)

            for exchange in top_exchanges:
                name = exchange.get("name", "Unknown")
                country = exchange.get("country", "Unknown")
                trade_volume = exchange.get("trade_volume_24h_btc", 0)

                exchange_row = ctk.CTkFrame(exchanges_frame, corner_radius=5)
                exchange_row.pack(pady=5, padx=5, fill="x", expand=True)

                name_label = ctk.CTkLabel(
                    exchange_row,
                    text=name,
                    font=("Arial", 14, "bold")
                )
                name_label.pack(side="left", padx=10)

                country_label = ctk.CTkLabel(
                    exchange_row,
                    text=f"Country: {country}",
                    font=("Arial", 12)
                )
                country_label.pack(side="left", padx=10)

                volume_label = ctk.CTkLabel(
                    exchange_row,
                    text=f"24h Volume: {trade_volume:.2f} BTC",
                    font=("Arial", 12)
                )
                volume_label.pack(side="right", padx=10)

        except Exception as e:
            error_label = ctk.CTkLabel(
                self.main_frame,
                text=f"Failed to fetch stock data: {e}",
                font=("Arial", 12, "italic")
            )
            error_label.pack(pady=10)

        back_button = ctk.CTkButton(
            self.main_frame,
            text="Back",
            command=lambda: self.show_bank_frame(self.current_customer_id)
        )
        back_button.pack(pady=20)


    def show_deposit_frame(self):
        self.clear_frame()

        # Заголовок
        label = ctk.CTkLabel(self.main_frame, text="Manage Deposit", font=("Arial", 20))
        label.pack(pady=20)

        try:
            cursor = self.conn.cursor()
            query = """
                SELECT deposit_id, amount, interest_rate, start_date, end_date
                FROM deposit
                WHERE account = ?
            """
            cursor.execute(query, (self.current_account_number,))
            deposit = cursor.fetchone()

            if deposit:
                deposit_id, amount, interest_rate, start_date, end_date = deposit

                deposit_info = ctk.CTkLabel(
                    self.main_frame,
                    text=(f"Deposit Balance: {amount:.2f} USD\n"
                          f"Interest Rate: {interest_rate:.2f}%\n"
                          f"Start Date: {start_date}\n"
                          f"End Date: {end_date if end_date else 'Active'}"),
                    font=("Arial", 14),
                    anchor="w"
                )
                deposit_info.pack(pady=10)

                withdraw_button = ctk.CTkButton(
                    self.main_frame,
                    text="Withdraw to Account",
                    command=lambda: self.withdraw_from_deposit(deposit_id, amount)
                )
                withdraw_button.pack(pady=10)

                add_button = ctk.CTkButton(
                    self.main_frame,
                    text="Add to Deposit",
                    command=lambda: self.add_to_deposit(deposit_id)
                )
                add_button.pack(pady=10)

                if amount == 0:
                    close_button = ctk.CTkButton(
                        self.main_frame,
                        text="Close Deposit",
                        command=lambda: self.close_deposit(deposit_id)
                    )
                    close_button.pack(pady=10)
                else:
                    warning_label = ctk.CTkLabel(
                        self.main_frame,
                        text="You can close the deposit only if the balance is 0.",
                        font=("Arial", 12),
                        fg_color="red"
                    )
                    warning_label.pack(pady=10)
            else:
                no_deposit_label = ctk.CTkLabel(self.main_frame, text="No active deposit found.")
                no_deposit_label.pack(pady=10)

                open_button = ctk.CTkButton(
                    self.main_frame,
                    text="Open Deposit",
                    command=self.open_deposit
                )
                open_button.pack(pady=10)

        except Exception as e:
            error_label = ctk.CTkLabel(self.main_frame, text=f"Error fetching deposit: {e}")
            error_label.pack(pady=20)

        back_button = ctk.CTkButton(
            self.main_frame,
            text="Back to menu",
            command=lambda: self.show_bank_frame(self.current_customer_id)
        )
        back_button.pack(pady=10)

    def open_deposit(self):
        try:
            cursor = self.conn.cursor()
            interest_rate = 3.5
            initial_amount = simpledialog.askfloat("Open Deposit", "Enter initial deposit amount:")

            if initial_amount is None or initial_amount <= 0:
                messagebox.showwarning("Invalid Amount", "Deposit amount must be greater than 0.")
                return

            query = """
                INSERT INTO deposit (account, interest_rate, amount)
                VALUES (?, ?, ?)
            """
            cursor.execute(query, (self.current_account_number, interest_rate, initial_amount))
            self.conn.commit()

            messagebox.showinfo("Success", "Deposit successfully opened!")
            self.show_deposit_frame()
        except Exception as e:
            messagebox.showerror("Error", f"Error opening deposit: {e}")

    def withdraw_from_deposit(self, deposit_id, amount):
        if amount <= 0:
            messagebox.showerror("Error", "There are not enough funds on the deposit to withdraw.")
            return

        try:
            cursor = self.conn.cursor()
            query = "UPDATE deposit SET amount = 0 WHERE deposit_id = ?"
            cursor.execute(query, (deposit_id,))
            self.conn.commit()
            update_account = """
                UPDATE accounts
                SET balance = balance + ?
                WHERE account_number = ?
            """
            cursor.execute(update_account, (amount, self.current_account_number))
            self.conn.commit()

            messagebox.showinfo("Successfully", "Funds have been successfully transferred to your account.")
        except Exception as e:
            messagebox.showerror("Error", f"Money transfer error: {e}")

    def add_to_deposit(self, deposit_id):
        amount = simpledialog.askfloat("Deposit replenishment", "Enter the amount:")
        if not amount or amount <= 0:
            messagebox.showerror("Error", "Enter the correct amount.")
            return

        try:
            cursor = self.conn.cursor()
            check_balance = """
                SELECT balance FROM accounts WHERE account_number = ?
            """
            cursor.execute(check_balance, (self.current_account_number,))
            account_balance = cursor.fetchone()[0]

            if amount > account_balance:
                messagebox.showerror("Error", "Insufficient funds in the main account.")
                return
            update_account = """
                UPDATE accounts
                SET balance = balance - ?
                WHERE account_number = ?
            """
            cursor.execute(update_account, (amount, self.current_account_number))

            update_deposit = """
                UPDATE deposit
                SET amount = amount + ?
                WHERE deposit_id = ?
            """
            cursor.execute(update_deposit, (amount, deposit_id))
            self.conn.commit()

            messagebox.showinfo("Successfully", "The deposit has been successfully replenished.")
        except Exception as e:
            messagebox.showerror("Error", f"Deposit replenishment error: {e}")

    def close_deposit(self, deposit_id, amount):
        if amount > 0:
            messagebox.showerror("Error", "You cannot close the deposit while there are funds on it.")
            return

        try:
            cursor = self.conn.cursor()
            query = "DELETE FROM deposit WHERE deposit_id = ?"
            cursor.execute(query, (deposit_id,))
            self.conn.commit()

            messagebox.showinfo("Successfully", "The deposit has been successfully closed.")
        except Exception as e:
            messagebox.showerror("Error", f"Deposit closing error: {e}")

    def show_credit_frame(self):
        self.clear_frame()

        # Заголовок
        label = ctk.CTkLabel(self.main_frame, text="Manage Credits", font=("Arial", 20))
        label.pack(pady=20)
        try:
            cursor = self.conn.cursor()
            query = """
                SELECT credit_id, credit_amount, interest_rate, start_date, end_date, mounthly_payment, remaining_balance, credit_status
                FROM credit
                WHERE customer_id = ? AND credit_status = 'active'
            """
            cursor.execute(query, (self.current_customer_id,))
            credit = cursor.fetchone()

            if credit:
                credit_id, amount, rate, start_date, end_date, monthly_payment, balance, status = credit

                credit_info = ctk.CTkLabel(
                    self.main_frame,
                    text=(
                        f"Credit Amount: {amount:.2f} USD\n"
                        f"Interest Rate: {rate:.2f}%\n"
                        f"Start Date: {start_date}\n"
                        f"End Date: {end_date}\n"
                        f"Monthly Payment: {monthly_payment:.2f} USD\n"
                        f"Remaining Balance: {balance:.2f} USD\n"
                        f"Status: {status}"
                    ),
                    font=("Arial", 14),
                    anchor="w"
                )
                credit_info.pack(pady=10)
                pay_button = ctk.CTkButton(
                    self.main_frame,
                    text="Make Payment",
                    command=lambda: self.make_credit_payment(credit_id, balance)
                )
                pay_button.pack(pady=5)
            else:
                no_credit_label = ctk.CTkLabel(self.main_frame, text="No active credits found.")
                no_credit_label.pack(pady=20)

        except Exception as e:
            error_label = ctk.CTkLabel(self.main_frame, text=f"Error fetching credits: {e}")
            error_label.pack(pady=20)
        new_credit_button = ctk.CTkButton(
            self.main_frame,
            text="Apply for New Credit",
            command=self.apply_for_credit
        )
        new_credit_button.pack(pady=10)

        back_button = ctk.CTkButton(
            self.main_frame,
            text="Back to menu",
            command=lambda: self.show_bank_frame(self.current_customer_id)
        )
        back_button.pack(pady=10)

    def apply_for_credit(self):
        credit_amount = simpledialog.askfloat("Credit Application", "Enter credit amount:")
        if not credit_amount or credit_amount <= 0:
            messagebox.showerror("Error", "Incorrect loan amount.")
            return

        try:
            cursor = self.conn.cursor()
            interest_rate = 5.0
            duration_months = 12
            monthly_payment = (credit_amount * (1 + (interest_rate / 100))) / duration_months

            query_active_credit = "SELECT credit_id FROM credit WHERE customer_id = ? AND credit_status = 'active'"
            cursor.execute(query_active_credit, (self.current_customer_id,))
            active_credit = cursor.fetchone()

            if active_credit:
                messagebox.showerror("Error", "You already have an active loan. Pay it off before making a new one.")
                return

            query_credit = """
                INSERT INTO credit (customer_id, credit_amount, interest_rate, start_date, end_date, mounthly_payment, remaining_balance, credit_status)
                VALUES (?, ?, ?, GETDATE(), DATEADD(MONTH, ?, GETDATE()), ?, ?, 'active')
            """
            cursor.execute(
                query_credit,
                (
                    self.current_customer_id,
                    credit_amount,
                    interest_rate,
                    duration_months,
                    monthly_payment,
                    credit_amount
                )
            )
            self.conn.commit()
            query_balance = """
                UPDATE accounts
                SET balance = balance + ?
                WHERE customer_id = ? AND is_active = 1
            """
            cursor.execute(query_balance, (credit_amount, self.current_customer_id))
            self.conn.commit()


            messagebox.showinfo("Successfully", "The loan has been successfully issued.")
            self.show_credit_frame()
        except Exception as e:
            messagebox.showerror("Error", f"Loan processing error: {e}")

    def make_credit_payment(self, credit_id, remaining_balance):
        payment_amount = simpledialog.askfloat("Make Payment", "Enter payment amount:")
        if not payment_amount or payment_amount <= 0:
            messagebox.showerror("Error", "Incorrect payment amount.")
            return

        try:
            cursor = self.conn.cursor()

            query_balance = "SELECT balance FROM accounts WHERE customer_id = ? AND is_active = 1"
            cursor.execute(query_balance, (self.current_customer_id,))
            current_balance = cursor.fetchone()[0]

            if payment_amount > current_balance:
                messagebox.showerror("Error", "The payment amount exceeds your current balance.")
                return

            if payment_amount > remaining_balance:
                messagebox.showerror("Error", "The payment amount exceeds the loan balance.")
                return

            query_update_balance = """
                UPDATE accounts
                SET balance = balance - ?
                WHERE customer_id = ? AND is_active = 1
            """
            cursor.execute(query_update_balance, (payment_amount, self.current_customer_id))

            query_update_credit = """
                UPDATE credit
                SET remaining_balance = remaining_balance - ?
                WHERE credit_id = ?
            """
            cursor.execute(query_update_credit, (payment_amount, credit_id))

            query_check_balance = "SELECT remaining_balance FROM credit WHERE credit_id = ?"
            cursor.execute(query_check_balance, (credit_id,))
            new_balance = cursor.fetchone()[0]
            if new_balance == 0:
                query_close_credit = "UPDATE credit SET credit_status = 'closed' WHERE credit_id = ?"
                cursor.execute(query_close_credit, (credit_id,))

            self.conn.commit()

            messagebox.showinfo("Successfully", "The payment was completed successfully.")
            self.show_credit_frame()
        except Exception as e:
            messagebox.showerror("Error", f"Payment execution error: {e}")

    def change_appearance_mode_event(self, new_appearance_mode: str):
        customtkinter.set_appearance_mode(new_appearance_mode)

    def show_employee_frame(self, employee_id):
        self.clear_frame()


        title_label = ctk.CTkLabel(
            self.main_frame,
            text="Employee Dashboard",
            font=("Arial", 24, "bold")
        )
        title_label.pack(pady=(20, 10))


        buttons_frame = ctk.CTkFrame(self.main_frame, corner_radius=8)
        buttons_frame.pack(pady=20, padx=20, fill="x")

        buttons = [
            ("View Active Credits", self.show_active_credits),
            ("Manage Accounts", self.manage_accounts),
            ("Credit Report", self.generate_credit_report),
            ("Manage Employees", self.manage_employee_accounts),
            ("Fraud Detection", self.fraud_detection)
        ]

        for text, command in buttons:
            button = ctk.CTkButton(
                buttons_frame,
                text=text,
                command=command
            )
            button.pack(pady=5)


        logout_button = ctk.CTkButton(
            self.main_frame,
            text="Log Out",
            command=self.show_login_frame
        )
        logout_button.pack(pady=20)

    def show_active_credits(self):
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Active Credits", font=("Arial", 18))
        label.pack(pady=20)

        try:
            cursor = self.conn.cursor()
            query = """
                SELECT credit_id, customer_id, credit_amount, interest_rate, start_date, remaining_balance
                FROM credit
                WHERE credit_status = 'active'
            """
            cursor.execute(query)
            credits = cursor.fetchall()

            if credits:
                for credit in credits:
                    credit_id, customer_id, amount, rate, start_date, balance = credit
                    credit_info = ctk.CTkLabel(
                        self.main_frame,
                        text=(
                            f"Credit ID: {credit_id}\n"
                            f"Customer ID: {customer_id}\n"
                            f"Amount: {amount:.2f} USD\n"
                            f"Interest Rate: {rate:.2f}%\n"
                            f"Start Date: {start_date}\n"
                            f"Remaining Balance: {balance:.2f} USD"
                        ),
                        font=("Arial", 14),
                        anchor="w"
                    )
                    credit_info.pack(pady=10)
            else:
                no_credits_label = ctk.CTkLabel(self.main_frame, text="No active credits found.")
                no_credits_label.pack(pady=20)
        except Exception as e:
            error_label = ctk.CTkLabel(self.main_frame, text=f"Error fetching active credits: {e}")
            error_label.pack(pady=20)


        back_button = ctk.CTkButton(self.main_frame, text="Back",
                                    command=lambda: self.show_employee_frame(self.current_employee_id))
        back_button.pack(pady=10)

    def manage_accounts(self):

        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Manage Accounts", font=("Arial", 18))
        label.pack(pady=20)
        actions = [
            ("Create Account", self.create_account),
            ("Block Account", self.block_account),
            ("Delete Account", self.delete_account)
        ]

        for text, command in actions:
            button = ctk.CTkButton(self.main_frame, text=text, command=command)
            button.pack(pady=5)
        back_button = ctk.CTkButton(self.main_frame, text="Back",
                                    command=lambda: self.show_employee_frame(self.current_employee_id))
        back_button.pack(pady=10)

    def create_account(self):
        messagebox.showinfo("Create Account", "The account creation function has not been implemented yet.")

    def block_account(self):
        messagebox.showinfo("Block Account", "The account blocking feature has not yet been implemented.")

    def delete_account(self):
        messagebox.showinfo("Delete Account", "The account deletion feature has not yet been implemented.")

    def start_fraud_detection(self):
        threading.Thread(target=self.fraud_detection).start()

    def prepare_data_for_prediction(self, data):
        data = data.rename(columns={
            'oldBalanceOrig': 'oldBalanceOrig',
            'newBalanceOrig': 'newBalanceOrig',
            'oldBalanceDest': 'oldBalanceDest',
            'newBalanceDest': 'newBalanceDest',
            'amount': 'amount'
        })

        data = data.fillna(0)

        for col in ['amount', 'oldBalanceOrig', 'newBalanceOrig', 'oldBalanceDest', 'newBalanceDest']:
            if len(np.unique(data[col])) == 1:
                print(f"Column {col} is constant. Skipping Box-Cox transformation.")
                data[f"{col}_boxcox"] = data[col]
            else:
                data[f"{col}_boxcox"], _ = boxcox(data[col] + 1)


        feature_names = ['amount_boxcox', 'oldBalanceOrig_boxcox', 'newBalanceOrig_boxcox',
                         'oldBalanceDest_boxcox', 'newBalanceDest_boxcox']
        X = data[feature_names]

        transaction_ids = data['transaction_id']

        return X, transaction_ids

    def fraud_detection(self):

        if not hasattr(self, 'current_employee_id') or self.current_employee_id is None:
            print("Employee ID is not set. Please log in as an employee.")
            return
        server = 'DESKTOP-3T1O5TL'
        database = 'BankAppDB'
        driver = 'ODBC Driver 18 for SQL Server'

        connection_str = (
                f"mssql+pyodbc:///?odbc_connect="
                + quote_plus(
            f"DRIVER={{{driver}}};"
            f"SERVER={server};"
            f"DATABASE={database};"
            "ENCRYPT=yes;"
            "TrustServerCertificate=yes;"
            "Trusted_Connection=yes;"
        )
        )

        try:
            engine = create_engine(connection_str)

            query = """
            SELECT transaction_id, account_from, account_to, oldBalanceOrig, newBalanceOrig, 
                   oldBalanceDest, newBalanceDest, amount, isFlaggedFraud
            FROM transactions
            WHERE status = 'pending'
            """
            data = pd.read_sql(query, engine)

            if data.empty:
                print("No pending transactions found.")
                return

            X, transaction_ids = self.prepare_data_for_prediction(data)
            try:
                logreg = joblib.load('C:/Users/Админ/OneDrive/Documents/3 курс курсовая/fraud_detection_model.pkl')
            except Exception as e:
                print(f"Error loading model: {e}")
                return
            predictions = logreg.predict(X)
            prediction_probabilities = logreg.predict_proba(X)[:, 1]
            for transaction_id, prediction, prob in zip(transaction_ids, predictions, prediction_probabilities):
                print(
                    f"Transaction ID: {transaction_id}, Fraud Probability: {prob:.2%}, Prediction: {'Fraudulent' if prediction else 'Legitimate'}")


            try:
                with engine.begin() as connection:
                    update_query = text("""
                        UPDATE transactions
                        SET isFlaggedFraud = :isFlaggedFraud, status = 'completed', employee_id = :employee_id
                        WHERE transaction_id = :transaction_id AND status = 'pending'
                    """)

                    account_update_query = text("""
                        UPDATE accounts
                        SET balance = :new_balance
                        WHERE account_number = :account_number
                    """)

                    fraudulent_count = 0
                    for transaction_id, prediction, prob, account_from, account_to, new_balance_orig, new_balance_dest in zip(
                            transaction_ids, predictions, prediction_probabilities, data['account_from'],
                            data['account_to'], data['newBalanceOrig'], data['newBalanceDest']):
                        is_fraud = int(prob >= 0.9)
                        connection.execute(update_query, {
                            'isFlaggedFraud': is_fraud,
                            'transaction_id': transaction_id,
                            'employee_id': self.current_employee_id
                        })
                        connection.execute(account_update_query, {
                            'new_balance': new_balance_orig,
                            'account_number': account_from
                        })
                        connection.execute(account_update_query, {
                            'new_balance': new_balance_dest,
                            'account_number': account_to
                        })

                        if is_fraud:
                            fraudulent_count += 1
            except Exception as e:
                print(f"Error during fraud detection process: {e}")

            print(f"Fraud detection completed: {fraudulent_count} fraudulent transactions flagged.")
        except Exception as e:
            print(f"Error during fraud detection process: {e}")

    def generate_credit_report(self):
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Credit Report", font=("Arial", 18))
        label.pack(pady=20)

        try:
            cursor = self.conn.cursor()
            query = """
                SELECT credit_status, COUNT(*), SUM(credit_amount)
                FROM credit
                GROUP BY credit_status
            """
            cursor.execute(query)
            report = cursor.fetchall()

            if report:
                for status, count, total in report:
                    report_info = ctk.CTkLabel(
                        self.main_frame,
                        text=(
                            f"Status: {status}\n"
                            f"Count: {count}\n"
                            f"Total Amount: {total:.2f} USD"
                        ),
                        font=("Arial", 14),
                        anchor="w"
                    )
                    report_info.pack(pady=10)
            else:
                no_report_label = ctk.CTkLabel(self.main_frame, text="No data available.")
                no_report_label.pack(pady=20)
        except Exception as e:
            error_label = ctk.CTkLabel(self.main_frame, text=f"Error generating report: {e}")
            error_label.pack(pady=20)

        back_button = ctk.CTkButton(self.main_frame, text="Back",
                                    command=lambda: self.show_employee_frame(self.current_employee_id))
        back_button.pack(pady=10)

    def manage_employee_accounts(self):
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Manage Employee Accounts", font=("Arial", 18))
        label.pack(pady=20)

        actions = [
            ("Add Employee", self.add_employee),
            ("Remove Employee", self.remove_employee)
        ]

        for text, command in actions:
            button = ctk.CTkButton(self.main_frame, text=text, command=command)
            button.pack(pady=5)
        back_button = ctk.CTkButton(self.main_frame, text="Back",
                                    command=lambda: self.show_employee_frame(self.current_employee_id))
        back_button.pack(pady=10)

    def add_employee(self):
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Add Employee", font=("Arial", 18))
        label.pack(pady=20)
        firstname_label = ctk.CTkLabel(self.main_frame, text="First Name:")
        firstname_label.pack()
        firstname_entry = ctk.CTkEntry(self.main_frame)
        firstname_entry.pack()

        lastname_label = ctk.CTkLabel(self.main_frame, text="Last Name:")
        lastname_label.pack()
        lastname_entry = ctk.CTkEntry(self.main_frame)
        lastname_entry.pack()

        phone_label = ctk.CTkLabel(self.main_frame, text="Phone:")
        phone_label.pack()
        phone_entry = ctk.CTkEntry(self.main_frame)
        phone_entry.pack()

        password_label = ctk.CTkLabel(self.main_frame, text="Password:")
        password_label.pack()
        password_entry = ctk.CTkEntry(self.main_frame, show="*")
        password_entry.pack()

        def save_employee():
            firstname = firstname_entry.get()
            lastname = lastname_entry.get()
            phone = phone_entry.get()
            password = password_entry.get()

            if not (firstname and lastname and phone and password):
                messagebox.showerror("Error", "All fields are required.")
                return

            try:
                cursor = self.conn.cursor()
                query = """
                    INSERT INTO employees (firstname, lastname, phone, password)
                    VALUES (?, ?, ?, ?)
                """
                cursor.execute(query, (firstname, lastname, phone, password))
                self.conn.commit()
                messagebox.showinfo("Success", "Employee added successfully.")
                self.manage_employee_accounts()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to add employee: {e}")

        save_button = ctk.CTkButton(self.main_frame, text="Save", command=save_employee)
        save_button.pack(pady=10)

        back_button = ctk.CTkButton(self.main_frame, text="Back",
                                    command=self.manage_employee_accounts)
        back_button.pack(pady=10)

    def remove_employee(self):
        self.clear_frame()

        label = ctk.CTkLabel(self.main_frame, text="Remove Employee", font=("Arial", 18))
        label.pack(pady=20)
        employee_id_label = ctk.CTkLabel(self.main_frame, text="Enter Employee ID:")
        employee_id_label.pack(pady=5)
        employee_id_entry = ctk.CTkEntry(self.main_frame)
        employee_id_entry.pack(pady=5)

        def confirm_removal():
            employee_id = employee_id_entry.get()
            if not employee_id.isdigit():
                messagebox.showerror("Error", "Employee ID must be a number.")
                return

            try:
                cursor = self.conn.cursor()
                check_query = "SELECT COUNT(*) FROM employees WHERE employee_id = ?"
                cursor.execute(check_query, (int(employee_id),))
                exists = cursor.fetchone()[0]
                if not exists:
                    messagebox.showerror("Error", "Employee ID not found.")
                    return

                delete_query = "DELETE FROM employees WHERE employee_id = ?"
                cursor.execute(delete_query, (int(employee_id),))
                self.conn.commit()
                messagebox.showinfo("Success", "Employee removed successfully.")
                self.manage_employee_accounts()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to remove employee: {e}")

        confirm_button = ctk.CTkButton(self.main_frame, text="Remove", command=confirm_removal)
        confirm_button.pack(pady=10)

        back_button = ctk.CTkButton(self.main_frame, text="Back", command=self.manage_employee_accounts)
        back_button.pack(pady=10)

    def clear_frame(self):
        for widget in self.main_frame.winfo_children():
            widget.destroy()

if __name__ == "__main__":
    app = AppBank()
    app.mainloop()
